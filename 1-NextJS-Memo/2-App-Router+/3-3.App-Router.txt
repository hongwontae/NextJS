1. 클라이언트 컴포넌트 Rule
1-1. 클라이언트 컴포넌트를 사용할 떄는 외부 파일로 아웃소싱하는 것이 좋다.
=> 최대한 서버 컴포넌트로 유지해야 성능 상 이점을 얻을 수 있다.
1-2. useHook은 대부분 클라이언트 컴포넌트에서 작동한다.


2. 동적 라우팅 안에 중첩된 일반 라우팅
2-1. 동적 라우팅 폴더 내부에 일반 라우팅 폴더를 넣어도 된다. => 이 떄도 일반적인 App-Router 방식으로 작동한다.
2-2. /news/${item.slug}/image => 이렇게 접근할 수 있다.


3. 인터셉팅 라우트
3-1. 페이지에 어떻게 도달하느냐에 따라서 보여주는 page.js를 다르게 설정하는 라우트이다.
3-2. ()가로챌 라우트Name, 소괄호 내부에는 (.)같은 level, (..)위의 level..
3-3. 일반적으로 내비게이션 이동을 가로채서 인터셉트 라우트를 보여준다. => 새로고침이나 직접적인 url로 접근하면 기존의 page.js를 보여준다.


4. 인터셉트 라우트 + 병렬 라우팅
4-1. 인터셉트 라우트안에 병렬 라우팅이 존재할 때 병렬 라우팅 폴더는 인터셉트 라우트를 무시하기 떄문에 .을 여러개 둘 필요가 없다.
(@modal 처럼 병렬 라우트는 애초에 url상에 존재하지는 않는다.)

4-2. 로직
1. [slug] 파일 내부에 page.js layout.js @image image 라우트가 존재한다.
=> 병렬 처리를 위해서 page.js를 children으로 @image의 (.)image의 page.js를 image props로 가져와서 렌더링한다.
=> @에 해당하는 라우트를 두 개 사용하지 않아도 children으로 하나의 라우트 구현가능
2. /image 요청이 오든 말든 병렬 라우트는 렌더링된다. 레이아웃에 규정해놓았기 때문이다.
3. 인터셉트의 경우 기존의 image 폴더의 page.js를 가로채는 거지만 인터셉트가 아닐 경우는 default.js에서 null을 반환하여
구조를 맞춰준다.





*** 어떤 라우팅 방식에 page.js default.js의 차이점과 어떤 걸 사용해야 할지
