1. NextJS의 캐시
1-1. Request Cache
1-2. Data Cache
1-3. Full Route Cache
1-4. Router Cache


2. Request Cache
2-1. Client => Server로 가는 Request와 그에 대한 응답을 캐시한다.
2-2. 2-1의 요청이 캐시되었기 떄문에 동일한 요청 떄 요청을 보내지 않고 응답을 재사용한다. (요청 x)
2-3. 이 떄 request url, headers 등 동일해야 한다.


3. Data Cache
3-1. 내부적으로 데이터를 가져오거나 저장하면 응답 데이터를 서버 측 캐시에 저장한다.
3-2. 그리고 해당 데이터를 지속적으로 재사용한다. NextJS에게 업데이트하라는 명령을 내리기 전까지
(page.js에서 통해 fetch 함수로 데이터를 전달한다. => 전달된 응답 데이터는 캐시된다. => 새로고침을 하더라도 전달된
캐시 데이터를 지속적으로 보여준다. => 성능 상 이점이 크지만 반응적이지 못하다.)
3-3. fetch config를 통해 cache를 제어할 수 있다.
(
    {cache : 'force cache' => default 설정이고 요청에 대한 캐시 응답 데이터만 보여준다.}
    {cache : 'no-store' => 응답 데이터를 캐시하지 않는다. 지속적으로 통신하여 가져온다.}
    {next : {
        revalidate : 10 => 응답 데이터를 캐시하지만 value된 시간만큼만 가지고 있겠다.
    }}
)


4. Data Cache File
4-1. 파일을 기준으로 데이터를 캐싱할 수 있다.
4-2. export const revalidate = number...
(export 키워드, revalidate 변수이름, value로 number가 필수이다.) (4-2는 파일의 root에 존재해야 한다.)
(4-2는 응답 데이터 캐시 시간을 정할 수 있다.)
4-3. export const dynamic = '...'
(export 키워드, dynamic 변수명, value로 정해진 String이 필수이다.) (4-3은 파일의 root에 존재해야 한다.)
(4-3은 기본값은 auto이다. => 응답 데이터를 캐시하고 요청을 보내지 않고 재사용한다.)
(4-3. 'force-dynamic' === cache:'no-store' => 캐시하지 않고 항상 요청)

4-4. import {unstable_noStore} from 'next/cache';
=> 적용된 컴포넌트만 응답 데이터를 캐시하지 않는 것을 명시한다.
=> 응답 데이터를 캐시하지 않길 원하는 컴포넌트 내부에 unstable_noStore을 호출해주면 된다.

4-5. revalidate, dynamic의 효과는 return된 자식 컴포넌트들도 효과를 이양받는다.
=> 그렇기에 4-4를 사용하여 어느 컴포넌트는 캐시되고 어느 컴포넌트는 캐시되지 않게 할 수 있다.


*** 2,3,4 모두 fetch에 의거한 설명이다.