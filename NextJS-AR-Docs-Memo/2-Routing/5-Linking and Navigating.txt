1. 각 라우트 navigate하는 방법은 4가지가 존재한다.
1-1. Link 컴포넌트
1-2. useRouter (CSR)
1-3. redirect (SSR)
1-4. History API


2. Link Component
2-1. <a> 태그를 확장, 클라이언트 사이드 내비게이션, 프리페칭을 지원하는 컴포넌트이다.
2-2. 페이지를 이동하면 스크롤 위치가 자동으로 페이지 상단으로 이동한다.
(<Link scroll={true/false} /> => false를 선택하면 이전 페이지의 스크롤 위치를 오버라이딩한다.)
(router.push('url', {scroll : false})) => 동일

2-3. Link를 사용하여 페이지로 이동할 떄 특정 요소로 스크롤
=> 이동되는 페이지의 요소의 id를 url 뒤에 붙여서 특정 요소로 스크롤한다.
=> <Link href="/about#section2">


2. useRouter
=> Next Hooks 


3. redirect function
3-1. 서버 컴포넌트에서 페이지를 이동할 떄 사용하는 함수이다.
3-2. import { redirect } from 'next/navigation'
3-3. try catch로 redirect를 덮으면 안된다. => 내부적으로 에러를 던져서 실행시키기 떄문이다.


4. How Routing and Navigation Works
4-1. 코드 스플리팅
1. 라우트 세그먼트에 해당하는 자원만 가져온다.


4-2. 프리페칭
1. 해당 경로에 도달하기 전에 페이지의 리소스를 미리 백그라운드에서 로드하는 방법
2. <Link> 컴포넌트가 뷰포트에 들어올 떄 프리페칭 진행
(<Link>로 향하는 페이지가 loading.js가 존재할 떄는 해당 페이지의 레이아웃만 로드한다.)
(모든 페이지를 프리페칭하는 것이 과부하가 일어날 수 도 있기 떄문이다.)
(prefetch={false || true} => 이를 통해서 프리페칭을 제어할 수 있다.)
3. router.prefetch() 훅을 사용해서 프로그래밍적으로 프리페칭 진행 
4. 프리페칭은 배포 모드에서만 적용된다.

=> app router일 경우 JS 번들, image, css등이 프리페칭
=> page router일 경우 js 번들, image, css, html 등이 프리페칭


4-3. 캐싱
1. Router Cache : 클라이언트에 페이지에 대한 정보들을 캐시하는 공간
2. 서버 컴포넌트 : Html이 전달되면 Router Cache에 각종 자원(image, css)와 렌더링 결과 JSON(메타데이터..)가 캐시된다.
(HTML를 저장하는게 아니라서 페이지 재 진입시 HTTP 요청을 보낸다. 그러나 캐시 데이터로 인해 빠른 접근 가능)
3. 클라이언트 컴포넌트 : JS 번들과 각종 자원이 Router Cache에 저장된다.


4-4. Partial Rendering
1. 페이지 전환시 변경된 부분만 재렌더링하고, 나머지 부분은 유지한다.
2. 데이터 전송량과 렌더링 시간 단축
3. layout.js가 공유된다면 재사용한다. => 재 요청 하지 않고 리렌더링하지 않는다.


5. Soft Navigation
1. 상태를 유지한다. => 전체 페이지를 다시 로드하지 않고 필요한 부분만 로드하고 렌더링하기 떄문이다.